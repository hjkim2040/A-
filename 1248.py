import sys
sys.stdin = open('input.txt', 'r')

T = int(input())
for tc in range(1, T + 1):
    # V 정점의 수, E 간선의 수, n1, n2 공통 조상을 찾는 두 개의 정점 번호
    V, E, n1, n2 = map(int, input().split())
    # arr은 간선 나열
    arr = list(map(int, input().split()))
    # chr은 그래프 혹은 트리 선언
    chr = [[] for _ in range(V + 1)]
    # 부모 배열
    par = [0] * (V + 1)
    check = [0] * (V + 1)  # n1 조상노드 표시

    # 간선의 수 만큼 반복
    for i in range(E):
        t1, t2 = arr[i * 2], arr[i * 2 + 1]
        # 그래프 만들기, 트리 만들기 => 단방향 그래프인 이유는 정점에서 내려가면서 서브트리의 크기를 측정하기 위해
        chr[t1].append(t2)
        # 부모가 누구인지 알 수 있게
        par[t2] = t1

    # n1 조상 찾기
    p = n1
    # p가 0이면 더 이상 조상이 없다
    while p != 0:
        # 거치는 곳 방문 표시 => 서브 트리 크기 측정을 위해?
        check[p] = 1
        # 계속 거슬러 올라감
        p = par[p]

    # n2 조상 중 n1 조상 찾기
    p = n2
    # check[p]가 1이면 공통 조상이기 때문에
    while check[p] == 0:
        p = par[p]

    q = [p] # 공통 조상을 배열로
    cnt = 0 # 서브트리의 크기
    while q:
        t = q.pop(0) # q의 첫번째 요소 꺼내기
        cnt += 1
        for w in chr[t]: # 꺼낸 요소와 트리로 연결되어 있는 요소를 q배열에 추가
            q.append(w)

    print(f'#{tc} {p} {cnt}')

# 1. 트리 혹은 그래프 구현을 위한 배열 초기화
# 2. 부모 노드를 찾기 위한 배열 초기화
# 3. 방문 배열 초기화
# 4. 입력받은 값으로 그래프 구현
# 5. 부모 노드 배열에 값 추가
# 6. 공통 조상을 찾을 첫 번째 숫자 조상 찾기 => 계속해서 부모 노드로 거슬러 올라가기, 방문 배열 체크하면서
# 7. 공통 조상을 찾을 두 번쨰 숫자 조상 찾기 => 방문 배열에 이미 방문 표시가 되어 있으면 그 정점이 공통 조상
# 8. 그 공통 조상으로 부터 파생된 서브 트리 크기 구하기
# 9. 공통 조상을 첫 번째로 bfs구현, 정점을 하나씩 지날 때 마다 cnt + 1

